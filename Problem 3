import torch
import torchvision
import torchvision.transforms as T
from torch.utils.data import DataLoader
import time

transform = T.Compose([
    T.ToTensor(),
    T.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))
])

trainset = torchvision.datasets.CIFAR10(
    root="/content/data", train=True, download=True, transform=transform)

testset = torchvision.datasets.CIFAR10(
    root="/content/data", train=False, download=True, transform=transform)

train_loader = DataLoader(trainset, batch_size=64, shuffle=True)
test_loader  = DataLoader(testset, batch_size=256, shuffle=False)

import torch.nn as nn

class CIFAR_FC_1HL(nn.Module):
    def __init__(self):
        super().__init__()
        self.net = nn.Sequential(
            nn.Flatten(),            
            nn.Linear(3072, 512),       
            nn.ReLU(),
            nn.Linear(512, 10)         
        )
    def forward(self, x):
        return self.net(x)

def train_fc(model, train_loader, test_loader, epochs=20, lr=1e-3):
    loss_fn = nn.CrossEntropyLoss()
    optimizer = torch.optim.Adam(model.parameters(), lr=lr)

    history = {"train_loss": [], "test_acc": []}
    start_time = time.time()

    for epoch in range(epochs):
        model.train()
        running_loss = 0.0
        for imgs, labels in train_loader:
            optimizer.zero_grad()
            out = model(imgs)
            loss = loss_fn(out, labels)
            loss.backward()
            optimizer.step()
            running_loss += loss.item() * imgs.size(0)

        train_loss = running_loss / len(train_loader.dataset)

    
        model.eval()
        correct, total = 0, 0
        with torch.no_grad():
            for imgs, labels in test_loader:
                out = model(imgs)
                preds = out.argmax(1)
                correct += (preds == labels).sum().item()
                total += labels.size(0)

        acc = correct / total
        history["train_loss"].append(train_loss)
        history["test_acc"].append(acc)

        print(f"Epoch {epoch+1}/{epochs} | Loss {train_loss:.4f} | Acc {acc:.4f}")

    total_time = time.time() - start_time
    print("Training Time:", total_time, "seconds")
    return history, total_time
model_a = CIFAR_FC_1HL()
history_a, t_a = train_fc(model_a, train_loader, test_loader, epochs=20)

class CIFAR_FC_3HL(nn.Module):
    def __init__(self):
        super().__init__()
        self.net = nn.Sequential(
            nn.Flatten(),
            nn.Linear(3072, 1024), nn.ReLU(),   
            nn.Linear(1024, 512), nn.ReLU(),
            nn.Linear(512, 256), nn.ReLU(),
            nn.Linear(256, 10)
        )
    def forward(self, x):
        return self.net(x)

model_b = CIFAR_FC_3HL()
history_b, t_b = train_fc(model_b, train_loader, test_loader, epochs=300)
